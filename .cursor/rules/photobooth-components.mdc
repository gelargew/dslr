---
globs: src/components/*
description: Component architecture and UI patterns for photobooth application
---

# Photobooth Component Architecture

## Component Organization

### Directory Structure
```
src/components/
├── ui/                     # shadcn/ui base components
├── photobooth/            # Photobooth-specific components
│   ├── Camera/
│   ├── Countdown/
│   ├── PhotoEditor/
│   ├── FrameSelector/
│   ├── IconOverlay/
│   └── PhotoPreview/
├── videotron/            # Videotron gallery components
│   ├── PhotoGrid/
│   ├── ScrollingRow/
│   └── NewPhotoAnimation/
└── shared/               # Shared utility components
    ├── Timer/
    ├── FullscreenLayout/
    └── TouchButton/
```

## Core Component Patterns

### Base Component Template
```typescript
// Component structure following existing patterns
import React from "react";
import { cn } from "@/utils/tailwind";

interface ComponentProps {
  className?: string;
  children?: React.ReactNode;
}

export default function Component({ className, children, ...props }: ComponentProps) {
  return (
    <div className={cn("base-classes", className)} {...props}>
      {children}
    </div>
  );
}
```

## Photobooth Components

### 1. Camera Component (`src/components/photobooth/Camera/WebcamCapture.tsx`)
```typescript
interface WebcamCaptureProps {
  onCapture: (photoData: string) => void;
  onError?: (error: Error) => void;
}

export default function WebcamCapture({ onCapture, onError }: WebcamCaptureProps) {
  // Implement webcam access via Electron IPC
  // Handle getUserMedia permissions
  // Provide capture functionality
}
```

### 2. Countdown Timer (`src/components/photobooth/Countdown/CountdownTimer.tsx`)
```typescript
interface CountdownTimerProps {
  startValue: number;
  onComplete: () => void;
  className?: string;
}

export default function CountdownTimer({ startValue, onComplete, className }: CountdownTimerProps) {
  // Animated countdown from startValue to 0
  // Call onComplete when reaching 0
  // Smooth animations with Tailwind
}
```

### 3. Photo Preview (`src/components/photobooth/PhotoPreview/PhotoDisplay.tsx`)
```typescript
interface PhotoDisplayProps {
  src: string;
  alt?: string;
  frame?: FrameTemplate;
  overlays?: IconOverlay[];
  className?: string;
}

export default function PhotoDisplay({ src, alt, frame, overlays, className }: PhotoDisplayProps) {
  // Display photo with optional frame and overlays
  // Handle responsive sizing
  // Support drag-and-drop for overlays
}
```

### 4. Frame Selector (`src/components/photobooth/FrameSelector/FrameSelector.tsx`)
```typescript
import { frameTemplates } from '@/assets/frames/frame-templates';

interface FrameSelectorProps {
  selectedFrame?: string;
  onFrameSelect: (frameId: string) => void;
  onTextChange: (text: string) => void;
}

export default function FrameSelector({ selectedFrame, onFrameSelect, onTextChange }: FrameSelectorProps) {
  // Use local frameTemplates array
  // Grid of frame template previews
  // Text input for frame customization
  // No database queries needed
}
```

### 5. Icon Overlay (`src/components/photobooth/IconOverlay/IconSelector.tsx`)
```typescript
import { overlayIcons } from '@/assets/icons/overlay-icons';

interface IconOverlay {
  id: string;
  iconId: string;
  position: { x: number; y: number };
  size: number;
  rotation: number;
}

interface IconSelectorProps {
  onIconAdd: (icon: IconOverlay) => void;
  selectedOverlays: IconOverlay[];
  onOverlayUpdate: (overlays: IconOverlay[]) => void;
}

export default function IconSelector({ onIconAdd, selectedOverlays, onOverlayUpdate }: IconSelectorProps) {
  // Use local overlayIcons array
  // Icon palette for selection
  // Drag-and-drop onto photo preview
  // Icon positioning and sizing controls
}
```

## Videotron Components

### 1. Photo Grid (`src/components/videotron/PhotoGrid/PhotoGrid.tsx`)
```typescript
interface PhotoGridProps {
  photos: PhotoData[];
  maxItems?: number;
  onNewPhoto?: (photo: PhotoData) => void;
}

export default function PhotoGrid({ photos, maxItems = 40, onNewPhoto }: PhotoGridProps) {
  // 4-row grid layout
  // Infinite horizontal scrolling
  // Row direction alternation (1,3 left, 2,4 right)
}
```

### 2. Scrolling Row (`src/components/videotron/ScrollingRow/ScrollingRow.tsx`)
```typescript
interface ScrollingRowProps {
  photos: PhotoData[];
  direction: 'left' | 'right';
  speed?: number;
  className?: string;
}

export default function ScrollingRow({ photos, direction, speed = 1, className }: ScrollingRowProps) {
  // Infinite horizontal scrolling
  // Smooth CSS animations
  // Seamless loop of photos
}
```

### 3. New Photo Animation (`src/components/videotron/NewPhotoAnimation/NewPhotoOverlay.tsx`)
```typescript
interface NewPhotoOverlayProps {
  photo: PhotoData;
  onAnimationComplete: () => void;
  duration?: number;
}

export default function NewPhotoOverlay({ photo, onAnimationComplete, duration = 5000 }: NewPhotoOverlayProps) {
  // Center-screen photo display
  // 5-second display duration
  // Fade-out animation
  // Auto-trigger onAnimationComplete
}
```

## Photo Generation

### Photo Composer (`src/helpers/photo-generator/photo-composer.ts`)
```typescript
export async function generateFinalPhoto(
  originalPhoto: string,
  frameTemplate?: FrameTemplate,
  frameText?: string,
  overlays: IconOverlay[] = []
): Promise<string> {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d')!;

  // Set standard photo size
  canvas.width = 1920;
  canvas.height = 1080;

  // 1. Draw original photo
  const img = await loadImage(originalPhoto);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  // 2. Apply frame if selected
  if (frameTemplate) {
    await applyFrame(ctx, frameTemplate, frameText, canvas.width, canvas.height);
  }

  // 3. Add overlay icons
  for (const overlay of overlays) {
    await drawOverlay(ctx, overlay);
  }

  return canvas.toDataURL('image/jpeg', 0.9);
}

async function loadImage(src: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}

async function applyFrame(
  ctx: CanvasRenderingContext2D,
  frame: FrameTemplate,
  text?: string,
  width: number,
  height: number
) {
  const { style } = frame;

  // Draw frame border
  if (style.backgroundColor) {
    ctx.fillStyle = style.backgroundColor;
    ctx.fillRect(0, 0, width, height);
  }

  // Draw frame border
  ctx.strokeStyle = style.borderColor;
  ctx.lineWidth = style.borderWidth;
  ctx.strokeRect(
    style.borderWidth / 2,
    style.borderWidth / 2,
    width - style.borderWidth,
    height - style.borderWidth
  );

  // Draw frame text
  if (text && style.titleStyle) {
    ctx.font = `${style.titleStyle.fontSize}px ${style.titleStyle.fontFamily}`;
    ctx.fillStyle = style.titleStyle.color;
    ctx.textAlign = 'center';

    const textY = style.titlePosition === 'bottom'
      ? height - style.borderWidth - 20
      : style.borderWidth + style.titleStyle.fontSize + 20;

    ctx.fillText(text, width / 2, textY);
  }
}

async function drawOverlay(ctx: CanvasRenderingContext2D, overlay: IconOverlay) {
  const icon = overlayIcons.find(i => i.id === overlay.iconId);
  if (!icon) return;

  const img = await loadImage(icon.iconPath);

  ctx.save();
  ctx.translate(overlay.position.x, overlay.position.y);
  ctx.rotate((overlay.rotation * Math.PI) / 180);
  ctx.drawImage(
    img,
    -overlay.size / 2,
    -overlay.size / 2,
    overlay.size,
    overlay.size
  );
  ctx.restore();
}
```

### Usage in Components
```typescript
// src/components/photobooth/PhotoEditor/PhotoEditor.tsx
export default function PhotoEditor() {
  const [finalPhoto, setFinalPhoto] = useState<string>();

  const handleSavePhoto = async () => {
    const generatedPhoto = await generateFinalPhoto(
      currentPhoto.file_path,
      selectedFrame,
      frameText,
      overlays
    );

    // Save generated photo
    const savedPhoto = await window.storageAPI.saveGeneratedPhoto(generatedPhoto, {
      originalPhotoId: currentPhoto.id,
      frameTemplateId: selectedFrame?.id,
      frameText,
      overlays,
    });

    setFinalPhoto(generatedPhoto);
  };
}
```

## Shared Components

### 1. Touch Button (`src/components/shared/TouchButton/TouchButton.tsx`)
```typescript
// Extend existing Button component for touch interfaces
interface TouchButtonProps extends ButtonProps {
  size?: 'touch-sm' | 'touch-md' | 'touch-lg';
  haptic?: boolean;
}

export default function TouchButton({ size = 'touch-md', haptic = false, ...props }: TouchButtonProps) {
  // Larger touch targets
  // Visual feedback on press
  // Optional haptic feedback
}
```

### 2. Fullscreen Layout (`src/components/shared/FullscreenLayout/FullscreenLayout.tsx`)
```typescript
interface FullscreenLayoutProps {
  children: React.ReactNode;
  background?: 'black' | 'white' | 'primary';
  className?: string;
}

export default function FullscreenLayout({ children, background = 'black', className }: FullscreenLayoutProps) {
  // Full viewport coverage
  // Remove all chrome/navigation
  // Background color options
}
```

### 3. Timer Hook (`src/components/shared/Timer/useTimer.tsx`)
```typescript
interface UseTimerProps {
  initialTime: number;
  onComplete?: () => void;
  onTick?: (remainingTime: number) => void;
  autoStart?: boolean;
}

export function useTimer({ initialTime, onComplete, onTick, autoStart = true }: UseTimerProps) {
  // Countdown timer hook
  // Auto-start option
  // Tick callbacks for UI updates
  // Completion callback
}
```

## Styling Guidelines

### Component Styling
- Use [Tailwind utility classes](mdc:src/styles/global.css)
- Follow existing [Button variants](mdc:src/components/ui/button.tsx)
- Implement touch-friendly sizing (min 44px targets)

### Responsive Design
```typescript
// Touch-optimized sizing
const touchSizes = {
  'touch-sm': 'h-12 px-6',      // 48px height
  'touch-md': 'h-16 px-8',      // 64px height
  'touch-lg': 'h-20 px-12',     // 80px height
};
```

### Animation Classes
```css
/* Add to global.css */
@layer utilities {
  .animate-countdown {
    @apply animate-pulse text-6xl font-bold;
  }

  .animate-scroll-left {
    animation: scroll-left 30s linear infinite;
  }

  .animate-scroll-right {
    animation: scroll-right 30s linear infinite;
  }

  .animate-photo-entrance {
    @apply animate-in fade-in zoom-in duration-1000;
  }

  .animate-photo-exit {
    @apply animate-out fade-out zoom-out duration-1000;
  }
}

@keyframes scroll-left {
  from { transform: translateX(100%); }
  to { transform: translateX(-100%); }
}

@keyframes scroll-right {
  from { transform: translateX(-100%); }
  to { transform: translateX(100%); }
}
```

## State Management Patterns

### Component State
```typescript
// Local component state for UI interactions
const [isCapturing, setIsCapturing] = useState(false);
const [countdown, setCountdown] = useState(3);
const [selectedFrame, setSelectedFrame] = useState<string>();
```

### Context for Photo Data
```typescript
// src/contexts/PhotoContext.tsx
interface PhotoContextType {
  currentPhoto?: PhotoData;
  capturedPhotos: PhotoData[];
  addPhoto: (photo: PhotoData) => void;
  updatePhoto: (id: string, updates: Partial<PhotoData>) => void;
}
```

Follow existing patterns from [ToggleTheme](mdc:src/components/ToggleTheme.tsx) and extend component library systematically.