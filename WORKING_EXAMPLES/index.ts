import { app, BrowserWindow, ipcMain } from 'electron';
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import sharp from 'sharp';
import express from 'express';
import { DIGICAM_CONFIG, WATCH_DIR, OVERLAY_PATH } from './constants/digicam';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1000,
    height: 700,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      webSecurity: false, // Disable web security
      allowRunningInsecureContent: true, // Allow mixed content
      nodeIntegrationInWorker: true, // Allow node integration in workers
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // CSP bypass - disable security headers
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': undefined
      }
    });
  });

  // Open the DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

// IPC handlers for camera control
ipcMain.handle('capture', async () => {
  try {
    await axios.get(DIGICAM_CONFIG.CAPTURE_URL);
    return { success: true, message: 'Capture initiated' };
  } catch (error: any) {
    console.error('Capture error:', error.message);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('check-dcc-status', async () => {
  try {
    const response = await axios.get(DIGICAM_CONFIG.LIVEVIEW_JSON_URL, { timeout: 3000 });
    return { connected: true, message: 'DigiCamControl connected' };
  } catch (error: any) {
    return { connected: false, error: error.message };
  }
});

// File watching for new captures
function setupFileWatcher() {
  // Ensure watch directory exists
  if (!fs.existsSync(WATCH_DIR)) {
    fs.mkdirSync(WATCH_DIR, { recursive: true });
    console.log('Created watch directory:', WATCH_DIR);
  }

  fs.watch(WATCH_DIR, async (event, filename) => {
    if (event === 'rename' && filename && filename.endsWith('.jpg')) {
      try {
        const input = path.join(WATCH_DIR, filename);

        // Wait a bit for the file to be fully written
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Check if file exists and is not already processed
        if (fs.existsSync(input) && !filename.startsWith('overlay_')) {
          const output = path.join(WATCH_DIR, `overlay_${filename}`);

          // Apply overlay if overlay image exists
          if (fs.existsSync(OVERLAY_PATH)) {
            await sharp(input)
              .composite([{ input: OVERLAY_PATH, gravity: 'center' }])
              .toFile(output);

            console.log('Overlay added:', output);

            // Notify renderer about new image
            if (mainWindow) {
              mainWindow.webContents.send('new-image', {
                original: filename,
                processed: `overlay_${filename}`
              });
            }
          }
        }
      } catch (error) {
        console.error('Error processing overlay:', error);
      }
    }
  });
}

// Express server for image sharing
function setupExpressServer() {
  const app = express();

  // Request logging middleware
  app.use((req, res, next) => {
    console.log(`üåê [${new Date().toISOString()}] ${req.method} ${req.url}`);
    next();
  });

  // Enable CORS for all routes
  app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
    console.log(`üîì CORS headers added for ${req.method} ${req.url}`);
    next();
  });

  // Serve photos directory
  app.use('/photos', express.static(WATCH_DIR));

  // Main gallery route
  app.get('/', (req, res) => {
    console.log(`üè† Serving main gallery page`);
    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Photobooth Gallery</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
          .header { text-align: center; margin-bottom: 30px; }
          .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
          .photo-item { background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
          .photo-item img { width: 100%; height: 200px; object-fit: cover; }
          .photo-info { padding: 15px; }
          .status { background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>üì∏ Photobooth Gallery</h1>
          <div class="status">
            <strong>Server Status:</strong> Running<br>
            <strong>Photo Directory:</strong> ${WATCH_DIR}<br>
            <strong>DigiCamControl:</strong> ${DIGICAM_CONFIG.BASE_URL}
          </div>
        </div>
        <div class="gallery" id="gallery">
          <p>Loading photos...</p>
        </div>
        <script>
          // Load photos dynamically
          fetch('/photos/')
            .then(response => response.text())
            .then(html => {
              const parser = new DOMParser();
              const doc = parser.parseFromString(html, 'text/html');
              const links = Array.from(doc.querySelectorAll('a[href$=".jpg"]'));
              const gallery = document.getElementById('gallery');

              if (links.length === 0) {
                gallery.innerHTML = '<p>No photos found. Capture some photos first!</p>';
              } else {
                gallery.innerHTML = links.map(link => \`
                  <div class="photo-item">
                    <img src="/photos/\${link.href.split('/').pop()}" alt="\${link.textContent}">
                    <div class="photo-info">
                      <strong>\${link.textContent}</strong><br>
                      <small><a href="/photos/\${link.href.split('/').pop()}" target="_blank">View Full Size</a></small>
                    </div>
                  </div>
                \`).join('');
              }
            })
            .catch(err => {
              document.getElementById('gallery').innerHTML = '<p>Error loading photos.</p>';
            });
        </script>
      </body>
      </html>
    `);
  });

  // API status endpoint
  app.get('/status', (req, res) => {
    console.log(`üìä Serving status API endpoint`);
    res.json({
      status: 'running',
      photoDir: WATCH_DIR,
      dccUrl: DIGICAM_CONFIG.BASE_URL,
      timestamp: new Date().toISOString()
    });
  });

  // Photos list API
  app.get('/api/photos', (req, res) => {
    try {
      const files = fs.readdirSync(WATCH_DIR)
        .filter(file => file.endsWith('.jpg'))
        .sort((a, b) => b.localeCompare(a)); // Most recent first

      res.json({
        photos: files.map(file => ({
          name: file,
          url: `/photos/${file}`,
          isProcessed: file.startsWith('overlay_'),
          timestamp: fs.statSync(path.join(WATCH_DIR, file)).mtime
        }))
      });
    } catch (error) {
      res.status(500).json({ error: 'Failed to read photos directory' });
    }
  });

  // Catch-all route for debugging
  app.use('*', (req, res) => {
    console.log(`‚ùå 404 - Route not found: ${req.method} ${req.url}`);
    res.status(404).json({
      error: 'Route not found',
      method: req.method,
      url: req.url,
      availableRoutes: ['/', '/status', '/api/photos', '/photos/']
    });
  });

  const PORT = 3001; // Change port to avoid conflicts
app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ Express server SUCCESSFULLY started on port ${PORT}!`);
    console.log(`üì∏ Express server running at http://localhost:${PORT}`);
    console.log('üìÅ Serving photos from:', WATCH_DIR);
    console.log(`üåê Gallery available at: http://localhost:${PORT}`);
    console.log(`üìä API status at: http://localhost:${PORT}/status`);
    console.log(`üîç Test this URL in browser: http://localhost:${PORT}/status`);
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  createWindow();
  setupFileWatcher();
  setupExpressServer();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
